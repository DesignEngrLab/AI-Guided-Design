function G = generate_sim_v3()
% essentially you're

%Other things to consider: 

% Some of these are from the previous concept of generating. You're not
% going to do that as much but keep it for a second before you delete
% them. Oh actually. It's better to just control the number on each and
% fuck around with things. You could also include that as an input for this
% function that way you can test a few different simulations and maybe even
% keep this simulation for another time! It' just dumb enough to be useful
% elsewhere...


pathLength = 1; % path length
pathSplitFactor = 1.2; % how angles change

cPath = [255, 190, 72]/256;
cTree = [55, 182, 16 ]/256;


startPos = [2,2];
startAngle = pi/12;
pathAngle = pi/24; %delta in path


seed = 7325;
rng(seed)



% For now it's easier to just add each thing manually

% add home
G = graph;
G = addnode(G, table({'H'}, {startPos},{startAngle},{'Home'},{cPath},...
    'VariableNames',{'Name', 'Pos','Angle','Type','Color'} ));

% Adding paths from the H node May need to modify this and the split node
% function to indicate what thing to attach to. I.E. return an index? Not
% entirely sure if that's necessary though. Might be for adding in
% additinoal split nodes.
[G, P1] = add_paths(G, 'H',0.125/2,10);

%There's no reason to add splits other than to prevent a thing from being
%made there????
[G, P1A] = add_paths(G, P1, 1, 10);
[G, P1B] = add_paths(G, P1, 0.125, 15);
[G, P1C] = add_paths(G, P1, -0.125, 10);


[G, P1A1] = add_paths(G, P1A, 1, 5);
[G, P1A2] = add_paths(G, P1A, 1.25, 10);
[G, P1A2A] = add_paths(G, P1A2, -1, 10);
[G, P1A2B] = add_paths(G, P1A2, 1.5, 10);

[G, P1A11a] = add_paths(G, P1A1, -0.5, 5);
[G, P1A11b] = add_paths(G, P1A11a, -0.5, 5);
[G, P1A11J] = add_paths(G, P1A11b, -0.5, 5);
[G, P1A11o1] = add_paths(G, P1A11a, -4, 5);
[G, P1A11o2]  = add_paths(G, P1A11b, 3, 10);

[G, P1B1] = add_paths(G, P1B, 0.8, 10);
[G, P1B2] = add_paths(G, P1B, 0.25, 22);

[G, P1B11a] = add_paths(G, P1B1, 0.75, 5);
[G, P1B11b] = add_paths(G, P1B11a, 0.75, 5);
[G, P1B11c] = add_paths(G, P1B11b, 0.75, 6);
[G, P1B11o1] = add_paths(G, P1B11a,3,10);
[G, P1B11o2] = add_paths(G, P1B11b,-3,10);

% Add that top area and join them
[G, P1B11J] = add_paths(G, P1B11c, -0.75, 8);
G = addedge(G, P1A11J, P1B11J);

% Continue and finish off that upper area
[G, PAB] = add_paths(G, P1B11J, -0.75, 1);
[G, PAB1] = add_paths(G, PAB, 0.75, 10);
[G, PAB2] = add_paths(G, PAB, -3.5, 6);
[G,PAB2a] = add_paths(G, PAB2, 1, 10);


% Working on that lowest one

[G, P1Co1] = add_paths(G, P1C, -1, 10);
[G, P1Cc1] = add_paths(G, P1C, -0.125, 10);
[G, P1Co2] = add_paths(G, P1Cc1, -1, 7);
[G, P1Cc2] = add_paths(G, P1Cc1, 0.25, 10);
[G, P1Cc3] = add_paths(G, P1Cc2, .75, 5);
G = update_angle(G, P1Cc2, 0.5);
[G, P1Co3] = add_paths(G, P1Cc2, 1.5, 10);
[G, P1Cc4] = add_paths(G, P1Cc3, 1, 15);
G = update_angle(G, P1Cc3, -0.5);
[G, P1Co4] = add_paths(G, P1Cc3, -1.62, 12);

[G, P1Co2c] = add_paths(G, P1Co2, 0.9, 15);

% Some other edges to add
G = addedge(G, P1Co4, P1Co2c);

[G, P1Cc5] = add_paths(G, P1Cc4, -1, 7);

G = addedge(G)
%
%
%add in offshoots...
j = 1; %name indexing for the e
for i = 1:numnodes(G)

    % If it's
    if strcmp(G.Nodes.Type{i},'Path') & rand < 0.5
        name = strcat('T',int2str(j));
        dA = -(pi/2)*(2*randi([0,1])-1);
        newX = G.Nodes.Pos{i}(1) + pathLength*cos(G.Nodes.Angle{i}+dA);
        newY = G.Nodes.Pos{i}(2) + pathLength*sin(G.Nodes.Angle{i}+dA);
        newA = 0; %doesn't matter
        
        G = addnode(G, table({name},{[newX, newY]},{newA},{'Tree'},{cTree},...
            'VariableNames',{'Name', 'Pos','Angle','Type','Color'} ));
        G = addedge(G,G.Nodes.Name{i},name);
        j = j +1;
    end
    
end
%}


%flip all the Y positions
%{
for i = 1:numnodes(G)
    G.Nodes.Pos{i}(2) = 50-G.Nodes.Pos{i}(2);

end
%}


function [G, name_prev] = add_paths(G,name_prev,curve_factor,total_p)
    % Function to add a set number of paths that curve a bit after
    % something.

    % figure out what number to be using for P nodes
    hasP = cellfun(@(x) contains(x, 'P'), G.Nodes.Name);
    numbers = cellfun(@(x) str2double(regexp(x, '\d+', 'match')), G.Nodes.Name(hasP));

    if isempty(numbers)
        n_p = 1; % just means we're starting out
    else
        n_p = max(numbers)+1;
    end

    % Add in first one manually based on previous

    in_p = find(cellfun(@(x) contains(x, name_prev), G.Nodes.Name));

    for j = n_p+1:(n_p+total_p)

        name = strcat('P',int2str(j-1));
    
        newX = G.Nodes.Pos{in_p}(1) + pathLength*cos(G.Nodes.Angle{in_p});
        newY = G.Nodes.Pos{in_p}(2) + pathLength*sin(G.Nodes.Angle{in_p});
        newA = G.Nodes.Angle{in_p} + curve_factor*pathAngle;

        G = addnode(G, table({name}, {[newX, newY]},{newA},{'Path'},{cPath},...
        'VariableNames',{'Name', 'Pos','Angle','Type','Color'} ));
    
        G = addedge(G,name_prev,name);

        in_p = numnodes(G);
        name_prev = name;
    end


end

    function [G, name] = add_split(G, name_prev,split_factor)
        % function that adds the split node. Includes the split factor,
        % which is key for the next node. With that though, you'll need to
        % figure out if the curve factor on the other thing will work well
        % in the neagtive and positive direction.
        % Unsure if I should 

    % figure out what number to be using for P nodes
    hasS = cellfun(@(x) contains(x, 'S'), G.Nodes.Name);
    numbers = cellfun(@(x) str2double(regexp(x, '\d+', 'match')), G.Nodes.Name(hasS));

    if isempty(numbers)
        name = 'S1';
    else
        name = strcat('S', int2str(max(numbers)+1));
    end
    
    i = find(cellfun(@(x) contains(x, name_prev), G.Nodes.Name));

    newX = G.Nodes.Pos{i}(1) + pathLength*cos(G.Nodes.Angle{i});
    newY = G.Nodes.Pos{i}(2) + pathLength*sin(G.Nodes.Angle{i});
    newA = G.Nodes.Angle{i} + split_factor*pathAngle*3;
    
    G = addnode(G, table({name}, {[newX, newY]},{newA},{'Split'},{cPath},...
    'VariableNames',{'Name', 'Pos','Angle','Type','Color'} ));
    
    G = addedge(G,name_prev,name);
    end

    function G = update_angle(G, name_prev,change)
    in_p = find(cellfun(@(x) contains(x, name_prev), G.Nodes.Name));
    G.Nodes.Angle{in_p} = G.Nodes.Angle{in_p}+change;
    end

end